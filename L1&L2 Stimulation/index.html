<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sun-Earth Lagrangian Points Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/jsm/controls/OrbitControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Tailwind's gray-900 */
            color: #e2e8f0; /* Tailwind's gray-200 */
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #info-overlay {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none; /* Allows clicks to pass through to canvas */
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            max-width: 300px;
            text-align: center;
            z-index: 10;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 5;
        }
        canvas {
            display: block;
            width: 100%;
            flex-grow: 1; /* Allows canvas to take available space */
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 150px;
            height: 8px;
            background: #4a5568; /* Tailwind gray-700 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1; /* Tailwind blue-500 */
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4299e1;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="speed-slider" class="text-sm">Simulation Speed:</label>
        <input type="range" id="speed-slider" min="0.1" max="5" value="1" step="0.1">
        <span id="speed-value" class="text-sm">1.0x</span>
    </div>
    <div id="info-overlay"></div>
    <canvas id="simulation-canvas"></canvas>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        import { OrbitControls } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/jsm/controls/OrbitControls.js';

        // --- Scene Setup ---
        let scene, camera, renderer, controls;
        let sun, earth, l1Marker, l2Marker, adityaL1, jwst;
        let earthOrbitRadius = 300; // Scaled distance for visualization (equivalent to 1 AU)
        let simulationSpeed = 1.0;
        let angle = 0; // Earth's orbital angle
        const G = 6.67430e-11; // Gravitational constant (not directly used for orbital path, but for force vectors)

        // Scaled masses (relative to Sun) - actual values will be huge, using ratios
        const M_SUN_SCALED = 1.989e30; // Actual Sun mass in kg
        const M_EARTH_SCALED = 5.972e24; // Actual Earth mass in kg
        // The ratio M_earth / M_sun is what matters for L-point approximation
        const MU = M_EARTH_SCALED / (M_SUN_SCALED + M_EARTH_SCALED); // Mass parameter

        const L1_OFFSET_FACTOR = Math.cbrt(MU / 3);
        const L2_OFFSET_FACTOR = Math.cbrt(MU / 3);

        const gravitationalVectors = [];
        const vectorGridSize = 10; // Number of vectors along one axis
        const vectorGridSpacing = 50; // Spacing between vectors

        // Info overlay element
        const infoOverlay = document.getElementById('info-overlay');
        let hoveredObject = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Dark background for space

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 400, 400); // Initial camera position

            // Renderer
            const canvas = document.getElementById('simulation-canvas');
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Orbit Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // For smoother camera movement
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // Limit panning to avoid losing focus
            controls.maxDistance = 1000;
            controls.minDistance = 50;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft ambient light
            scene.add(ambientLight);

            const sunLight = new THREE.PointLight(0xffffff, 2, 0, 0); // Strong white light from the Sun
            sunLight.position.set(0, 0, 0);
            scene.add(sunLight);

            // Sun
            const sunGeometry = new THREE.SphereGeometry(30, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 }); // Orange-yellow for the Sun
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);

            // Earth
            const earthGeometry = new THREE.SphereGeometry(10, 32, 32);
            const earthMaterial = new THREE.MeshLambertMaterial({ color: 0x0077be }); // Blue for Earth
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.position.set(earthOrbitRadius, 0, 0); // Initial position
            scene.add(earth);

            // Earth's Orbit Path (for visualization)
            const orbitGeometry = new THREE.RingGeometry(earthOrbitRadius - 1, earthOrbitRadius + 1, 64);
            const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = Math.PI / 2; // Rotate to lie flat in XY plane
            scene.add(orbit);

            // Lagrangian Points Markers (L1, L2)
            const lPointGeometry = new THREE.SphereGeometry(3, 16, 16);
            const lPointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red for L-points

            // L1 Calculation: between Sun and Earth
            // r_L1 = R - R * (M_earth / (3 * M_sun))^(1/3)
            const l1Distance = earthOrbitRadius - (earthOrbitRadius * L1_OFFSET_FACTOR);
            l1Marker = new THREE.Mesh(lPointGeometry, lPointMaterial);
            l1Marker.position.set(l1Distance, 0, 0);
            l1Marker.name = 'L1';
            scene.add(l1Marker);

            // L2 Calculation: beyond Earth
            // r_L2 = R + R * (M_earth / (3 * M_sun))^(1/3)
            const l2Distance = earthOrbitRadius + (earthOrbitRadius * L2_OFFSET_FACTOR);
            l2Marker = new THREE.Mesh(lPointGeometry, lPointMaterial);
            l2Marker.position.set(l2Distance, 0, 0);
            l2Marker.name = 'L2';
            scene.add(l2Marker);

            // Spacecrafts (Aditya-L1 at L1, JWST at L2)
            const spacecraftGeometry = new THREE.BoxGeometry(5, 5, 5); // Simple cube
            const adityaMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa }); // Gray
            adityaL1 = new THREE.Mesh(spacecraftGeometry, adityaMaterial);
            adityaL1.position.copy(l1Marker.position);
            adityaL1.name = 'Aditya-L1';
            scene.add(adityaL1);

            const jwstMaterial = new THREE.MeshLambertMaterial({ color: 0xeeeeee }); // White/Silver
            jwst = new THREE.Mesh(spacecraftGeometry, jwstMaterial);
            jwst.position.copy(l2Marker.position);
            jwst.name = 'JWST';
            // Optional: Add a simple sunshield for JWST
            const sunshieldGeometry = new THREE.BoxGeometry(10, 1, 8);
            const sunshieldMaterial = new THREE.MeshLambertMaterial({ color: 0x888800 }); // Gold/Yellowish
            const sunshield = new THREE.Mesh(sunshieldGeometry, sunshieldMaterial);
            sunshield.position.z = -5; // Behind JWST
            jwst.add(sunshield); // Attach sunshield to JWST
            scene.add(jwst);

            // Create Gravitational Vector Field
            createGravitationalVectorField();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            canvas.addEventListener('mousemove', onMouseMove);
            document.getElementById('speed-slider').addEventListener('input', (event) => {
                simulationSpeed = parseFloat(event.target.value);
                document.getElementById('speed-value').textContent = `${simulationSpeed.toFixed(1)}x`;
            });

            // Start animation loop
            animate();
        }

        // --- Gravitational Vector Field Visualization ---
        function createGravitationalVectorField() {
            // Clear existing vectors
            gravitationalVectors.forEach(arrow => scene.remove(arrow));
            gravitationalVectors.length = 0;

            const sunPosition = sun.position;
            const earthPosition = earth.position;

            for (let i = -vectorGridSize / 2; i <= vectorGridSize / 2; i++) {
                for (let j = -vectorGridSize / 2; j <= vectorGridSize / 2; j++) {
                    const x = i * vectorGridSpacing;
                    const y = j * vectorGridSpacing;

                    // Skip drawing vectors very close to the Sun or Earth to avoid extreme values and clutter
                    if (new THREE.Vector3(x, y, 0).distanceTo(sunPosition) < 40 ||
                        new THREE.Vector3(x, y, 0).distanceTo(earthPosition) < 20) {
                        continue;
                    }

                    // Calculate net gravitational force at this point
                    const point = new THREE.Vector3(x, y, 0);
                    const netForce = calculateNetGravitationalForce(point, sunPosition, earthPosition);

                    // Scale force for visualization
                    const forceMagnitude = netForce.length();
                    const scaledForce = netForce.clone().normalize().multiplyScalar(Math.min(forceMagnitude * 10, 40)); // Cap length

                    // Color based on magnitude (e.g., green for weak, red for strong)
                    let color = new THREE.Color();
                    if (forceMagnitude < 0.0001) { // Close to zero at L-points
                        color.set(0x00ff00); // Green for very weak force
                    } else if (forceMagnitude < 0.001) {
                        color.set(0xffff00); // Yellow
                    } else {
                        color.set(0xff0000); // Red for strong force
                    }

                    const arrowHelper = new THREE.ArrowHelper(scaledForce.normalize(), point, scaledForce.length(), color.getHex(), 5, 2);
                    gravitationalVectors.push(arrowHelper);
                    scene.add(arrowHelper);
                }
            }
        }

        // --- Gravitational Force Calculation ---
        function calculateNetGravitationalForce(point, sunPos, earthPos) {
            const tempM_SUN = M_SUN_SCALED * 1e-25; // Scale down for calculation as G is large
            const tempM_EARTH = M_EARTH_SCALED * 1e-25; // Scale down for calculation

            // Force from Sun
            const vecToSun = sunPos.clone().sub(point);
            const distToSunSq = vecToSun.lengthSq();
            const forceSunMagnitude = (G * tempM_SUN) / distToSunSq;
            const forceSun = vecToSun.normalize().multiplyScalar(forceSunMagnitude);

            // Force from Earth
            const vecToEarth = earthPos.clone().sub(point);
            const distToEarthSq = vecToEarth.lengthSq();
            const forceEarthMagnitude = (G * tempM_EARTH) / distToEarthSq;
            const forceEarth = vecToEarth.normalize().multiplyScalar(forceEarthMagnitude);

            // Add forces (vector sum)
            return forceSun.add(forceEarth);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            controls.update(); // Only required if controls.enableDamping or controls.autoRotate are set to true

            // Update Earth's orbital position
            angle += 0.005 * simulationSpeed; // Adjust speed
            earth.position.x = earthOrbitRadius * Math.cos(angle);
            earth.position.z = earthOrbitRadius * Math.sin(angle); // Z for a planar orbit

            // Update L1 and L2 positions relative to Sun-Earth line
            const sunX = sun.position.x;
            const earthX = earth.position.x;
            const earthZ = earth.position.z;

            // Recalculate L1 and L2 positions based on current Earth position
            const sunEarthVector = earth.position.clone().sub(sun.position);
            const sunEarthDistance = sunEarthVector.length();
            const sunEarthDirection = sunEarthVector.normalize();

            // L1 position: From Sun, along Sun-Earth line, minus offset from Earth
            const l1Pos = sun.position.clone().add(sunEarthDirection.clone().multiplyScalar(sunEarthDistance * (1 - L1_OFFSET_FACTOR)));
            l1Marker.position.copy(l1Pos);
            adityaL1.position.copy(l1Pos);

            // L2 position: From Sun, along Sun-Earth line, plus offset beyond Earth
            const l2Pos = sun.position.clone().add(sunEarthDirection.clone().multiplyScalar(sunEarthDistance * (1 + L2_OFFSET_FACTOR)));
            l2Marker.position.copy(l2Pos);
            jwst.position.copy(l2Pos);

            // Update gravitational vectors (recreate them for accurate visualization)
            // This can be computationally intensive, only do if needed or optimize
            // For now, let's update their direction/length based on new positions
            updateGravitationalVectors();

            renderer.render(scene, camera);
        }

        // Updates the vectors for the gravitational field.
        function updateGravitationalVectors() {
            const sunPosition = sun.position;
            const earthPosition = earth.position;

            let arrowIndex = 0;
            for (let i = -vectorGridSize / 2; i <= vectorGridSize / 2; i++) {
                for (let j = -vectorGridSize / 2; j <= vectorGridSize / 2; j++) {
                    const x = i * vectorGridSpacing;
                    const y = j * vectorGridSpacing;

                    if (new THREE.Vector3(x, y, 0).distanceTo(sunPosition) < 40 ||
                        new THREE.Vector3(x, y, 0).distanceTo(earthPosition) < 20) {
                        continue;
                    }

                    const point = new THREE.Vector3(x, y, 0);
                    const netForce = calculateNetGravitationalForce(point, sunPosition, earthPosition);

                    const forceMagnitude = netForce.length();
                    const scaledForce = netForce.clone().normalize().multiplyScalar(Math.min(forceMagnitude * 10, 40));

                    let color = new THREE.Color();
                    if (forceMagnitude < 0.0001) {
                        color.set(0x00ff00);
                    } else if (forceMagnitude < 0.001) {
                        color.set(0xffff00);
                    } else {
                        color.set(0xff0000);
                    }

                    if (gravitationalVectors[arrowIndex]) {
                        const arrow = gravitationalVectors[arrowIndex];
                        arrow.setDirection(scaledForce.normalize());
                        arrow.setLength(scaledForce.length());
                        arrow.setColor(color.getHex());
                        arrow.position.copy(point); // Ensure position is updated
                    }
                    arrowIndex++;
                }
            }
        }


        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects([l1Marker, l2Marker, adityaL1, jwst]);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object !== hoveredObject) {
                    // New object hovered
                    hoveredObject = object;
                    displayInfo(hoveredObject);
                }
                // Keep info visible and updated if same object is hovered
                positionInfoOverlay(event.clientX, event.clientY);
                infoOverlay.style.opacity = 1;
            } else {
                // No object hovered
                if (hoveredObject) {
                    hoveredObject = null;
                    infoOverlay.style.opacity = 0;
                }
            }
        }

        // --- Info Overlay Functions ---
        function displayInfo(object) {
            let infoText = "";
            let infoTitle = "";

            switch (object.name) {
                case 'L1':
                    infoTitle = "L1 Lagrangian Point";
                    infoText = "Point of stable equilibrium between the Sun and Earth. Ideal for solar observation as it allows a constant view of the Sun.";
                    break;
                case 'L2':
                    infoTitle = "L2 Lagrangian Point";
                    infoText = "Point of semi-stable equilibrium beyond Earth, opposite the Sun. Ideal for space telescopes as it offers a shielded, cold, and stable environment away from Sun/Earth interference.";
                    break;
                case 'Aditya-L1':
                    infoTitle = "Aditya-L1 Spacecraft";
                    infoText = "ISRO's mission to study the Sun, specifically its corona, chromosphere, and solar emissions. Located at the L1 point for an uninterrupted view of the Sun.";
                    break;
                case 'JWST':
                    infoTitle = "James Webb Space Telescope (JWST)";
                    infoText = "NASA's premier space observatory, designed to conduct infrared astronomy. Located at the L2 point to maintain a cold operating temperature, shielded from the Sun and Earth, for deep space observations.";
                    break;
                default:
                    infoTitle = "Unknown Object";
                    infoText = "";
            }
            infoOverlay.innerHTML = `<h3 class="font-bold text-lg mb-1">${infoTitle}</h3><p class="text-sm">${infoText}</p>`;
        }

        function positionInfoOverlay(mouseX, mouseY) {
            infoOverlay.style.left = `${mouseX + 15}px`;
            infoOverlay.style.top = `${mouseY + 15}px`;
        }

        // --- Initialize the simulation on window load ---
        window.onload = init;

    </script>
</body>
</html>
